/**
 * (c) 2003-2012 MuleSoft, Inc. This software is protected under international
 * copyright law. All use of this software is subject to MuleSoft's Master
 * Subscription Agreement (or other Terms of Service) separately entered
 * into between you and MuleSoft. If such an agreement is not in
 * place, you may not use the software.
 **/

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.module.kindling;

import java.net.URI;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.UriBuilder;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.mule.api.ConnectionException;
import org.mule.api.ConnectionExceptionCode;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Connect;
import org.mule.api.annotations.ConnectionIdentifier;
import org.mule.api.annotations.Connector;
import org.mule.api.annotations.Disconnect;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.ValidateConnection;
import org.mule.api.annotations.param.ConnectionKey;
import org.mule.api.annotations.param.Optional;
import org.mule.module.kindling.exception.KindlingConnectorException;
import org.mule.module.kindling.exception.KindlingConnectorUnauthorizedException;
import org.mule.module.kindling.types.KindlingCategoryState;
import org.mule.module.kindling.types.KindlingCommentParentType;
import org.mule.module.kindling.types.KindlingCommentType;
import org.mule.module.kindling.types.KindlingIdeaFilter;
import org.mule.module.kindling.types.KindlingState;
import org.mule.module.kindling.types.KindlingUserDigest;
import org.mule.module.kindling.types.KindlingUserReputationTimeframe;
import org.mule.module.kindling.types.KindlingUserState;

import com.sun.jersey.api.client.Client;
import com.sun.jersey.api.client.UniformInterfaceException;
import com.sun.jersey.api.client.WebResource;
import com.sun.jersey.api.client.filter.HTTPBasicAuthFilter;

/**
 * Kindling Cloud Connector
 * <p>
 * Kindling ignites innovation by connecting people and ideas
 * <p>
 * Allows to connect to the kindling site across the Kindling Service API.
 * Connector created with the documentation of the service for the version v3.9.2.0
 * <p>
 * The supported actions provided for each entity are:
 * <table>
 * 	<tr>
 * 		<td>Entity name</td>
 * 		<td>Retrieve Collection</td>
 * 		<td>Retrieve single</td>
 * 		<td>Create</td>
 * 		<td>Update</td>
 * 		<td>Delete</td>
 * 	</tr>
 * 	<tr>
 * 		<td>Group</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td></td>		
 * 	</tr>
 * 	<tr>
 * 		<td>Comment</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td></td>
 * 		<td>x</td>		
 * 	</tr>
 * 	<tr>
 * 		<td>Idea</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td></td>		
 * 	</tr>
 * 	<tr>
 * 		<td>User</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td>x</td>		
 * 	</tr>
 * 	<tr>
 * 		<td>Category</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td>x</td>
 * 		<td></td>		
 * 	</tr>
 * </table>
 * 
 * @author MuleSoft, Inc.
 */
@Connector(name="kindling", schemaVersion="1.0", friendlyName="Kindling")
public class KindlingConnector
{
	static final private Log logger = LogFactory.getLog(KindlingConnector.class);
	
	static final private String API_URL = "https://%s.kindlingapp.com/api/";
	
	/**
	 * The name of the company registered in kindling and used for access your site like https://{companyName}.kindlingapp.com
	 */
	@Configurable
	private String companyName;
	
	private String jerseyUser;
	
	private Client jerseyClient;
	
	public String getCompanyName() {
		return companyName;
	}

	public void setCompanyName(String companyName) {
		this.companyName = companyName;
	}
	
	public void setJerseyClient(Client jerseyClient) {
		this.jerseyClient = jerseyClient;
	}
	
    /**
     * Connect
     *
     * @param username A username
     * @param password A password
     * @throws ConnectionException
     */
    @Connect
    public void connect(@ConnectionKey String username, String password)
        throws ConnectionException {
    	jerseyClient = new Client();
        HTTPBasicAuthFilter authFilter = new HTTPBasicAuthFilter(username, password);
        // Add basic auth filter for all the
        jerseyClient.addFilter(authFilter);
        
        jerseyUser = username;
        
        // Call getGroups with the first result to check the authentication process
        try {
        	retrieveGroups(0, null, 0, 1, null, null, null);
        } catch (KindlingConnectorUnauthorizedException e) {
        	throw new ConnectionException(ConnectionExceptionCode.INCORRECT_CREDENTIALS, null, e.getMessage());
        } catch (KindlingConnectorException e) {
        	throw new ConnectionException(ConnectionExceptionCode.UNKNOWN, null, e.getMessage());
        }
    }

    /**
     * Disconnect
     */
    @Disconnect
    public void disconnect() {
    	jerseyClient = null;
    	jerseyUser = null;
    }

    /**
     * Are we connected
     */
    @ValidateConnection
    public boolean isConnected() {
        return jerseyClient != null;
    }

    /**
     * Are we connected
     */
    @ConnectionIdentifier
    public String connectionId() {
        return "001";
    }

    
    /**
     * Gets the groups collection
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:retrieve-groups}
     * 
     * @param depth <i>Default: 0.</i> Any object in the result can be displayed at depth, 0 = no depth, 1 = expand first relational object level, etc.
     * @param sort <i>Default: title.</i> How the collection output will be sorted, like 'date ASC', 'date', or 'name DESC' etc.
     * @param page <i>Default: 1.</i> The page requested
     * @param limit <i>Default: 20</i> The limit on number of collection items to show per page
     * @param state <i>Default: ACTIVATED.</i> Get only items in the collection that are in the given state, either by a state ID or it's natural language name
     * @param startsWith find group titles beginning with this string
     * @param query a general group search
     * @return group.json-collection
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String retrieveGroups(@Optional Integer depth,
	    						@Optional String sort,
	    						@Optional Integer page,
	    						@Optional Integer limit,
	    						@Optional KindlingState state,
	    						@Optional String startsWith,
	    						@Optional String query) 
    		throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	URI uri = getBaseUriBuilder().path("groups").build();
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	// Check for optional parameters (do not send them if they have their default value)
    	if (depth != null && depth > 0)
    		wr = wr.queryParam("depth", String.valueOf(depth));
    	
    	if (!StringUtils.isEmpty(sort))
    		wr = wr.queryParam("sort", sort);
    	
    	if (page != null && page > 1)
    		wr = wr.queryParam("page", String.valueOf(page));
    	
    	if (limit != null && limit > 0)
    		wr = wr.queryParam("limit", String.valueOf(limit));
    	
    	if (state != null)
    		wr = wr.queryParam("state", state.getValue());
    	
    	if (!StringUtils.isEmpty(startsWith))
    		wr = wr.queryParam("startsWith", startsWith);
    	
    	if (!StringUtils.isEmpty(query))
    		wr = wr.queryParam("q", query);
    	
    	logger.info("Requesting retrieveGroups to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.GET, null);
    }
    
    /**
     * Gets a single group
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:retrieve-group}
     * 
     * @param groupId The id of the group to retrieve
     * @param depth <i>Default: 0.</i> Any object in the result can be displayed at depth, 0 = no depth, 1 = expand first relational object level, etc.
     * group.json
     * @return group.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String retrieveGroup(String groupId, @Optional Integer depth)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(groupId))
    		throw new KindlingConnectorException("The groupId parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("groups/{groupId}").build(groupId);
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	// Check for optional parameters (do not send them if they have their default value)
    	if (depth != null && depth > 0)
    		wr = wr.queryParam("depth", String.valueOf(depth));
    	    	    	
    	logger.info("Requesting retrieveGroup to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.GET, null);
    }
    
    /**
     * Updates a single group
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:update-group}
     * 
     * @param groupId  The id of the group to retrieve
     * @param groupJson The group to create in JSON format
     * @return group.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String updateGroup(String groupId, String groupJson)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(groupId))
    		throw new KindlingConnectorException("The groupId parameter it's required");
    	
    	if (StringUtils.isEmpty(groupJson))
    		throw new KindlingConnectorException("The groupJson parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("groups/{groupId}").build(groupId);
    	
    	WebResource wr = jerseyClient.resource(uri);
    	    	    	
    	logger.info("Requesting updateGroup to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.PUT, groupJson);
    }
    
    /**
     * Create a new group in the groups collection
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:create-group}
     * 
     * @param groupJson The group to create in JSON format
     * @return group.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String createGroup(String groupJson)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(groupJson))
    		throw new KindlingConnectorException("The groupJson parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("groups").build();
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	logger.info("Requesting createGroup to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.POST, groupJson); 
    }

    /**
     * Gets the comments collection
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:get-comments}
     * 
     * @param parentType Retrieve only comments whose parent is of this type
     * @param depth <i>Default: 0.</i> Any object in the result can be displayed at depth, 0 = no depth, 1 = expand first relational object level, etc.
     * @param sort <i>Default: title.</i> How the collection output will be sorted, like 'date ASC', 'date', or 'name DESC' etc.
     * @param page <i>Default: 1.</i> The page requested
     * @param limit <i>Default: 20</i> The limit on number of collection items to show per page
     * @param state <i>Default: ACTIVATED.</i> Get only items in the collection that are in the given state, either by a state ID or it's natural language name
     * @param parentId Retrieve only comments of a specific parent ID
     * @param type The type of comments to retrieve
     * @return comment.json-collection
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    public String getComments(
    						KindlingCommentParentType parentType,
    						@Optional Integer depth,
							@Optional String sort,
							@Optional Integer page,
							@Optional Integer limit,
							@Optional KindlingState state,
							@Optional Integer parentId,
							@Optional KindlingCommentType type)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (parentType == null)
    		throw new KindlingConnectorException("The parentType parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("comments").build();
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	// Check for optional parameters (do not send them if they have their default value)
    	wr = wr.queryParam("parentType", parentType.getValue());
    	
    	if (depth != null && depth > 0)
    		wr = wr.queryParam("depth", String.valueOf(depth));
    	
    	if (!StringUtils.isEmpty(sort))
    		wr = wr.queryParam("sort", sort);
    	
    	if (page != null && page > 1)
    		wr = wr.queryParam("page", String.valueOf(page));
    	
    	if (limit != null && limit > 0)
    		wr = wr.queryParam("limit", String.valueOf(limit));
    	
    	if (state != null)
    		wr = wr.queryParam("state", state.getValue());
    	
    	if (parentId != null && parentId > 0)
    		wr = wr.queryParam("parentId", String.valueOf(parentId));
    	
    	if (type != null)
    		wr = wr.queryParam("type", type.getValue());
    	    	
    	logger.info("Requesting getComments to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.GET, null);
    }
    
    /**
     * Creates a new comment in the comments collection
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:create-comment}
     *     
     * @param commentJson A comment representation in JSON format
     * @return comment.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String createComment(String commentJson)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (commentJson == null)
    		throw new KindlingConnectorException("The commentJson parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("comments").build();
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	logger.info("Requesting createComment to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.POST, commentJson);
    }
    
    /**
     * Gets a single comment
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:retrieve-comment}
     * 
     * @param commentId The id of the comment to retrieve
     * @param depth <i>Default: 0.</i> Any object in the result can be displayed at depth, 0 = no depth, 1 = expand first relational object level, etc.
     * @return comment.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String retrieveComment(String commentId, @Optional Integer depth)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(commentId))
    		throw new KindlingConnectorException("The commentId parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("comments/{commentId}").build(commentId);
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	if (depth != null && depth > 0)
    		wr = wr.queryParam("depth", String.valueOf(depth));
    	
    	logger.info("Requesting retrieveComment to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.GET, null);
    }
    
    /**
     * Deletes a single comment
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:delete-comment}
     * 
     * @param commentId The id of the comment to delete
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public void deleteComment(String commentId)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(commentId))
    		throw new KindlingConnectorException("The commentId parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("comments/{commentId}").build(commentId);
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	logger.info("Requesting deleteComment to: " + wr.toString());
    	webResourceGet(wr, WebResourceMethods.DELETE, null);
    }
    
    /**
     * Gets the ideas collection
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:retrieve-ideas}
     * 
     * @param depth <i>Default: 0.</i> Any object in the result can be displayed at depth, 0 = no depth, 1 = expand first relational object level, etc.
     * @param sort <i>Default: title.</i> How the collection output will be sorted, like 'date ASC', 'date', or 'name DESC' etc.
     * @param page <i>Default: 1.</i> The page requested
     * @param limit <i>Default: 20</i> The limit on number of collection items to show per page
     * @param state Get only items in the collection that are in the given state, either by a state ID or it's natural language name
     * <p>
     * <li>
     * 	<ul>drafted</ul>
     * 	<ul>open</ul>
     * 	<ul>approved/ul>
     * 	<ul>completed</ul>
     * 	<ul>declined</ul>
     * 	<ul>paused</ul>
     * 	<ul>others depending on workflow settings</ul>
     * </li>
     * @param allowsVoting only show ideas that can or cannot be voted upon
     * @param query a general idea search string
     * @param authorId show only ideas from a particular author
     * @param categoryId show only ideas in a particular category
     * @param filter conceptual filters
     * @return ideas.json-collection
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String retrieveIdeas(@Optional Integer depth,
								@Optional String sort,
								@Optional Integer page,
								@Optional Integer limit,
								@Optional String state,
								@Optional Boolean allowsVoting,
								@Optional String query,
								@Optional String authorId,
								@Optional String categoryId,
								@Optional KindlingIdeaFilter filter)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	URI uri = getBaseUriBuilder().path("ideas").build();
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	// Check for optional parameters (do not send them if they have their default value)
    	if (depth != null && depth > 0)
    		wr = wr.queryParam("depth", String.valueOf(depth));
    	
    	if (!StringUtils.isEmpty(sort))
    		wr = wr.queryParam("sort", sort);
    	
    	if (page != null && page > 1)
    		wr = wr.queryParam("page", String.valueOf(page));
    	
    	if (limit != null && limit > 0)
    		wr = wr.queryParam("limit", String.valueOf(limit));
    	
    	if (!StringUtils.isEmpty(state))
    		wr = wr.queryParam("state", state);
    	
    	if (allowsVoting != null)
    		wr = wr.queryParam("allowsVoting", String.valueOf(allowsVoting));
    	
    	if (!StringUtils.isEmpty(query))
    		wr = wr.queryParam("q", query);
    	
    	if (!StringUtils.isEmpty(authorId))
    		wr = wr.queryParam("authorId", authorId);
    	
    	if (!StringUtils.isEmpty(categoryId))
    		wr = wr.queryParam("categoryId", categoryId);
    	
    	if (filter != null)
    		wr = wr.queryParam("filter", filter.getValue());
    	
    	logger.info("Requesting retrieveIdeas to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.GET, null);
    }
    
    /**
     * Create a new idea in the ideas collection
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:create-idea}
     * 
     * @param ideaJson The representation of an Idea in JSON format
     * @return idea.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String createIdea(String ideaJson)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(ideaJson))
    		throw new KindlingConnectorException("The ideaJson parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("ideas").build();
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	logger.info("Requesting createIdea to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.POST, ideaJson);
    }
    
    /**
     * Gets a single idea
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:retrieve-idea}
     * 
     * @param ideaId The id of the Idea to retrieve
     * @param depth <i>Default: 0.</i> Any object in the result can be displayed at depth, 0 = no depth, 1 = expand first relational object level, etc.
     * @return idea.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String retrieveIdea(	String ideaId,
    							@Optional Integer depth)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(ideaId))
    		throw new KindlingConnectorException("The ideaId parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("ideas/{ideaId}").build(ideaId);
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	if (depth != null && depth > 0)
    		wr = wr.queryParam("depth", String.valueOf(depth));
    	
    	logger.info("Requesting retrieveIdea to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.GET, null);
    }
    
    /**
     * Updates a single idea
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:update-idea}
     * 
     * @param ideaId The id of the Idea to update
     * @param ideaJson The representation of the Idea in JSON format
     * @return idea.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String updateIdea(String ideaId, String ideaJson)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(ideaId))
    		throw new KindlingConnectorException("The ideaId parameter it's required");
    	
    	if (StringUtils.isEmpty(ideaJson))
    		throw new KindlingConnectorException("The ideaJson parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("ideas/{ideaId}").build(ideaId);
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	logger.info("Requesting updateIdea to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.PUT, ideaJson);
    }
    
    /**
     * Gets the users collection
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:retrieve-users}
     * 
     * @param depth <i>Default: 0.</i> Any object in the result can be displayed at depth, 0 = no depth, 1 = expand first relational object level, etc.
     * @param sort <i>Default: title.</i> How the collection output will be sorted, like 'date ASC', 'date', or 'name DESC' etc.
     * @param page <i>Default: 1.</i> The page requested
     * @param limit <i>Default: 20.</i> The limit on number of collection items to show per page
     * @param state <i>Default: ACTIVATED.</i> Get only items in the collection that are in the given state, either by a state ID or it's natural language name
     * @param associatedWithCategoryId only show users associated with a particular category
     * @param digest show only users with a particular type of digest set
     * @param query general user search string
     * @param reputationTimeframe if present, will turn this request into one specifically for reputation leaders for a given timeframe, which may be combined with the associatedWithCategoryId parameter as well to return a leaderbooard for a category
     * @return user.json-collection
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String retrieveUsers(@Optional Integer depth,
								@Optional String sort,
								@Optional Integer page,
								@Optional Integer limit,
								@Optional KindlingUserState state,
								@Optional Integer associatedWithCategoryId,
								@Optional KindlingUserDigest digest,
								@Optional String query,
								@Optional KindlingUserReputationTimeframe reputationTimeframe)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	URI uri = getBaseUriBuilder().path("users").build();
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	// Check for optional parameters (do not send them if they have their default value)
    	if (depth != null && depth > 0)
    		wr = wr.queryParam("depth", String.valueOf(depth));
    	
    	if (!StringUtils.isEmpty(sort))
    		wr = wr.queryParam("sort", sort);
    	
    	if (page != null && page > 1)
    		wr = wr.queryParam("page", String.valueOf(page));
    	
    	if (limit != null && limit > 0)
    		wr = wr.queryParam("limit", String.valueOf(limit));
    	
    	if (state != null)
    		wr = wr.queryParam("state", state.getValue());
    	
    	if (associatedWithCategoryId != null && associatedWithCategoryId > 0)
    		wr = wr.queryParam("associatedWithCategoryId", String.valueOf(associatedWithCategoryId));
    	
    	if (digest != null)
    		wr = wr.queryParam("hasDigests", digest.getValue());
    	
    	if (!StringUtils.isEmpty(query))
    		wr = wr.queryParam("q", query);
   	
    	if (reputationTimeframe != null)
    		wr = wr.queryParam("reputationTimeframe", reputationTimeframe.getValue());
    	
    	logger.info("Requesting retrieveUsers to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.GET, null);
    }
    
    /**
     * Creates a new user in the users collection
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:create-user}
     * 
     * @param userJson The user to create in JSON format
     * @return user.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String createUser(String userJson)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (userJson == null)
    		throw new KindlingConnectorException("The userJson parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("users").build();
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	logger.info("Requesting createUser to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.POST, userJson);
    }
    
    /**
     * Gets a single user
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:create-user}
     * 
     * @param userId The id of the user to retrieve
     * @param depth <i>Default: 0.</i> Any object in the result can be displayed at depth, 0 = no depth, 1 = expand first relational object level, etc.
     * @return user.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String retrieveUser(	String userId,
    							@Optional Integer depth)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (userId == null)
    		throw new KindlingConnectorException("The userId parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("users/{userId}").build(userId);
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	if (depth != null)
    		wr = wr.queryParam("depth", String.valueOf(depth));
    	
    	logger.info("Requesting retrieveUser to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.GET, null);
    }
    
    /**
     * Updates a single user
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:update-user}
     * 
     * @param userId The id of the user to update
     * @param userJson The representation of the user in JSON format
     * @return user.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String updateUser(String userId, String userJson)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(userId))
    		throw new KindlingConnectorException("The userId parameter it's required");
    	
    	if (StringUtils.isEmpty(userJson))
    		throw new KindlingConnectorException("The userJson parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("users/{userId}").build(userId);
    	
    	WebResource wr = jerseyClient.resource(uri);
    	    	
    	logger.info("Requesting updateUser to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.PUT, userJson);
    }
    
    /**
     * Deletes a single user
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:delete-user}
     * 
     * @param userId The id of the user to delete
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public void deleteUser(String userId)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(userId))
    		throw new KindlingConnectorException("The userId parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("users/{userId}").build(userId);
    	
    	WebResource wr = jerseyClient.resource(uri);
    	    	
    	logger.info("Requesting deleteUser to: " + wr.toString());
    	webResourceGet(wr, WebResourceMethods.DELETE, null);
    }
    
    /**
     * Gets the categories collection
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:retrieve-categories}
     * 
     * 
     * @param depth <i>Default: 0.</i> Any object in the result can be displayed at depth, 0 = no depth, 1 = expand first relational object level, etc.
     * @param sort <i>Default: title.</i> How the collection output will be sorted, like 'date ASC', 'date', or 'name DESC' etc.
     * @param page <i>Default: 1.</i> The page requested
     * @param limit <i>Default: 20.</i> The limit on number of collection items to show per page
     * @param state <i>Default: ACTIVATED.</i> Get only items in the collection that are in the given state, either by a state ID or it's natural language name
     * @param query a general category search
     * @param associatedWithUserId If provided, will only return categories that the given user ID has access to
     * @return category.json-collection
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String retrieveCategories(@Optional Integer depth,
									@Optional String sort,
									@Optional Integer page,
									@Optional Integer limit,
									@Optional KindlingCategoryState state,
									@Optional String query,
									@Optional Integer associatedWithUserId)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	URI uri = getBaseUriBuilder().path("categories").build();
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	// Check for optional parameters (do not send them if they have their default value)
    	if (depth != null && depth > 0)
    		wr = wr.queryParam("depth", String.valueOf(depth));
    	
    	if (!StringUtils.isEmpty(sort))
    		wr = wr.queryParam("sort", sort);
    	
    	if (page != null && page > 1)
    		wr = wr.queryParam("page", String.valueOf(page));
    	
    	if (limit != null && limit > 0)
    		wr = wr.queryParam("limit", String.valueOf(limit));
    	
    	if (state != null)
    		wr = wr.queryParam("state", state.getValue());
    	
    	if (!StringUtils.isEmpty(query))
    		wr = wr.queryParam("q", query);
    	
     	if (associatedWithUserId != null && associatedWithUserId > 0)
    		wr = wr.queryParam("associatedWithUserId", String.valueOf(associatedWithUserId));
    	
    	logger.info("Requesting retrieveCategories to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.GET, null);
    }
    
    /**
     * Creates a new category in the categories collection
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:create-category}
     * 
     * @param categoryJson The category representation to create in JSON format
     * @return category.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String createCategory(String categoryJson)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(categoryJson))
    		throw new KindlingConnectorException("The categoryJson parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("categories").build();
    	
    	WebResource wr = jerseyClient.resource(uri);
    	    	
    	logger.info("Requesting createCategory to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.POST, categoryJson);
    }
    
    /**
     * Gets a single category
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:retrieve-category}
     * 
     * @param categoryId The id of the category to retrieve
     * @param depth <i>Default: 0.</i> Any object in the result can be displayed at depth, 0 = no depth, 1 = expand first relational object level, etc.
     * @return category.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String retrieveCategory(	String categoryId,
    								@Optional Integer depth)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(categoryId))
    		throw new KindlingConnectorException("The categoryId parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("categories/{categoryId}").build(categoryId);
    	
    	WebResource wr = jerseyClient.resource(uri);
    	
    	if (depth != null && depth > 0)
    		wr = wr.queryParam("depth", String.valueOf(depth));
    	    	
    	logger.info("Requesting retrieveCategory to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.GET, null);
    }
    
    /**
     * Updates a single category
     * <p>
     * {@sample.xml ../../../doc/kindling-connector.xml.sample kindling:update-category}
     * 
     * @param categoryId The id of the category to update
     * @param categoryJson The category representation in JSON format
     * @return category.json
     * @throws KindlingConnectorException If something goes wrong with the service API this exception is throw
     * @throws KindlingConnectorUnauthorizedException If the credentials provided for the user are wrong or are expired this exception is throw
     */
    @Processor
    public String updateCategory(String categoryId, String categoryJson)
    	throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
    	
    	if (StringUtils.isEmpty(categoryId))
    		throw new KindlingConnectorException("The categoryId parameter it's required");
    	
    	if (StringUtils.isEmpty(categoryJson))
    		throw new KindlingConnectorException("The categoryJson parameter it's required");
    	
    	URI uri = getBaseUriBuilder().path("categories/{categoryId}").build(categoryId);
    	
    	WebResource wr = jerseyClient.resource(uri);
    	    	
    	logger.info("Requesting updateCategory to: " + wr.toString());
    	return webResourceGet(wr, WebResourceMethods.PUT, categoryJson);
    }
    
    private UriBuilder getBaseUriBuilder() {
    	return UriBuilder.fromPath(String.format(API_URL, companyName));
    }
    
    private String webResourceGet(WebResource wr, WebResourceMethods method, String requestBody) 
			throws KindlingConnectorException, KindlingConnectorUnauthorizedException {
		try {
			return webResourceCallByEnumType(wr, method, requestBody);
		} catch (UniformInterfaceException e) {
			int statusCode = e.getResponse().getStatus();
			
			// The code 204 is returned as a successful operation with no response, but as the expected parameter is a String.class it throws a UniformInterfaceException.
			if (statusCode == 204) {
				return "";
			} else if (statusCode == 401) {
				throw new KindlingConnectorUnauthorizedException(jerseyUser);
			} else {
				throw new KindlingConnectorException("ERROR - statusCode: " + statusCode, e);
			}
		}
	}
    
    private String webResourceCallByEnumType(WebResource wr, WebResourceMethods method, String requestBody) {
		if (WebResourceMethods.GET.equals(method)) {
			return wr.type(MediaType.APPLICATION_JSON_TYPE).get(String.class);
		} else if (WebResourceMethods.POST.equals(method)) {
			return wr.type(MediaType.APPLICATION_JSON_TYPE).post(String.class, requestBody);
		} else if (WebResourceMethods.PUT.equals(method)) {
			return wr.type(MediaType.APPLICATION_JSON_TYPE).put(String.class, requestBody);
		} else if (WebResourceMethods.DELETE.equals(method)) {
			return wr.type(MediaType.APPLICATION_JSON_TYPE).delete(String.class);
		} else {
			return null;
		}
	}
    
    static private enum WebResourceMethods {
		GET,
		POST,
		PUT,
		DELETE;
	}
}
